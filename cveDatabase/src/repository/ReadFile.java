package repository;

import java.io.File;
import java.io.FileNotFoundException;
import java.security.Key;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.print.attribute.standard.RequestingUserName;

import dataModels.CVEObjForRepository;
import dataModels.CVEObject;
import dataModels.CVEObject.ColumnValues;
import dataModels.DatabaseConnectionObject;
import dataModels.InsertFeedback;
import dataModels.Message;
import sun.misc.*;

public class ReadFile {

	private MySQlRepository mySQlRepository=new MySQlRepository();
	private File file;
	Thread tr;

	
	
	public void readFileTest(String filePath, String brancheName, Message message){
		

		ArrayList<CVEObject> cveObjectList=new ArrayList<>();
		
		 tr=new Thread(){
			 boolean error=false;
    		@Override
    		public void run() {
    			
    				Scanner sc = null;
					try {
						sc = new Scanner(new File(filePath));
					} catch (FileNotFoundException e1) {
						
						e1.printStackTrace();
					}
					int count =1;
					
	    		while(sc.hasNextLine()){
	    			
	    			try {
	                    synchronized (message) {

	                    	CVEObject cveObject=new CVEObject();
	                    	
	                    	String line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("PACKAGE NAME")){
		    						cveObject.setProduct(linePart[1].trim());
		    					}else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Eerror in input PACKAGE NAME format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+" .There is no valu for PACKAGE NAME ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("PACKAGE VERSION")){
		    						cveObject.setComment(linePart[1].trim());
		    					}else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Error in input PACKAGE VERSION format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+" .There is no valu for PACKAGE VERSION ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("CVE")){
		    						cveObject.setCve(linePart[1].trim());
		    					}else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Error in input CVE format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+" .There is no valu for  CVE ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("CVE STATUS"))
		    						if(linePart[1].trim().equals("Patched")){
		    							cveObject.setMaster(CVEObject.ColumnValues.Unknown);
		    							cveObject.setRelease(CVEObject.ColumnValues.Fixed);
		    					
		    						}else{  
		    							cveObject.setMaster(CVEObject.ColumnValues.Unknown);
		    							cveObject.setRelease(CVEObject.ColumnValues.NotFixed);
		    						}
		    					else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Error in input CVE STATUS format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+" .There is no valu for CVE STATUS ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("CVE SUMMARY")){

		    						cveObject.setDescription(linePart[1].trim());
		    					}else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Error in input CVE SUMMARY format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+" .There is no valu for CVE SUMMARY ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("CVSS v2 BASE SCORE")){
		    						cveObject.setScore(Double.valueOf(linePart[1].trim()));
		    					}else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Error in input CVSS v2 BASE SCORE format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+". There is no valu for CVSS v2 BASE SCORE ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("VECTOR")){
		    						cveObject.setVector(linePart[1].trim());
		    					}else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Error in input VECTOR format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+" .There is no valu for VECTOR ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				line=sc.nextLine();
		    				if(!line.isEmpty()){
		    					String [] linePart=line.split(":");
		    					if(linePart[0].trim().equals("MORE INFORMATION")){
		    						cveObject.setMoreInformation(linePart[1].trim()+":"+linePart[2].trim());
		    					}else {
		    						message.setMessage("ERROR in Item Nr "+count+" .Error in input MORE INFORMATION format");
		    						message.notify();
		    						error=true;
		    						break;
		    					}
		    				}else{
		    					message.setMessage("ERROR in Item Nr "+count+" .There is no valu for MORE INFORMATION ");
		    					message.notify();
	    						error=true;
	    						break;
		    				}
		    				
		    				
	                    	message.setMessage("Item "+count+" "+cveObject.getCve()+" has been read successfully");
	                    	cveObject.setEdited(false);
	                    	cveObject.setReleaseName(brancheName);
	                    	cveObjectList.add(cveObject);
	                    	count++;
	                    	if(sc.hasNextLine()){
	                    		sc.nextLine();//jump over the empty line
	                    	}
	                    	message.notify();
	                    }
	                    
	                    Thread.sleep(10);
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                } 
    			
    			}
    			sc.close();
    			
    			if(error){
    				cveObjectList.clear();	
    				synchronized (message) {
    					
    					try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
       				 message.setMessage("End");
       	    		message.notify();
       			 }
				}else{
					synchronized (message) {
						
						message.setMessage(--count+" items has been  read from file successfully");
	    	    		message.notify();
					}
					
					int addedItem = mySQlRepository.addNewCVEListToDatabase(cveObjectList);
					if(addedItem==-1){//if there is a problem in connecting to database
						try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						synchronized (message) {
							message.setMessage("Connection Error");
		    	    		message.notify();
						}
					}else{
						
						String txt=Integer.toString(addedItem)+" items have been added in CVE table\n"+
								Integer.toString(cveObjectList.size()-addedItem)+" items have been updated in CVE Table\n";
						try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						synchronized (message) {
							message.setMessage(txt);
		    	    		message.notify();
						}
						try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						synchronized (message) {
		    				message.setMessage("End");
		    	    		message.notify();
		    			 }
					}
//					
				}
    			
    			tr.stop();
    			
    			
    		}
    		
    		
    		
		};
		tr.start();
	}
	
	

	public DatabaseConnectionObject getDatabaseConnectionInfo() {
		File file = new File("setting.txt");
		Scanner scanner;
		DatabaseConnectionObject connectionObject = new DatabaseConnectionObject();
		try {
			scanner = new Scanner(file);
			if (scanner.hasNextLine()) {
				String line = scanner.nextLine();
				Scanner column = new Scanner(line);
				if (column.hasNext())
					connectionObject.setHostAddress(column.next());
				if (column.hasNext())
					connectionObject.setPort(column.next());
				if (column.hasNext())
					connectionObject.setUserName(column.next());
				if (column.hasNext())
					connectionObject.setPassword(decrypPassword(column.next()));
				column.close();

			}
		} catch (FileNotFoundException e) {
			System.out.println("setting.txt not found");
		}

		return connectionObject;
	}

	

	/***
	 * Decrypt input String
	 * 
	 * @param encryptedData
	 * @return
	 */
	private String decrypPassword(String encryptedData) {

		Key key;
		String decryptedValue = "error";
		try {
			key = generateKey();
			Cipher c = Cipher.getInstance("AES");
			c.init(Cipher.DECRYPT_MODE, key);
			byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
			byte[] decValue = c.doFinal(decordedValue);
			decryptedValue = new String(decValue);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return decryptedValue;
	}

	private static Key generateKey() throws Exception {
		byte[] keyValue = new byte[] { 'C', 'V', 'E', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', '2', '0', '1', '7', '2' };
		Key key = new SecretKeySpec(keyValue, "AES");
		return key;
	}
}
