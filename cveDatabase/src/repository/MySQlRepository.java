package repository;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.ArrayList;

import dataModels.CVEObject;
import dataModels.DatabaseConnectionObject;
import dataModels.InsertFeedback;
import dataModels.OutPutFormat;
import dataModels.CVEObject.CVEDataState;

public class MySQlRepository {
	private String DATABASENAME = "cve_data";
	private String ADDRESS = "localhost";
	private String PORT = "3306";
	private String URL = "jdbc:mysql://";
	private String CHARACTEREncoding = "characterEncoding=UTF-8";
	private String SSL = "useSSL=false";
	private String USER = "root";
	private String PASSWORD = "root";
	
	
	private final int CONNECTION_ERROR=-1;
	private final int ITEM_NOT_FOUND=-2;
	

	private static Statement statement;
	private static Connection connection;
	
	private enum _tableName{
		cve_tb,master_tb,package_tb,release_tb,user_tb;
	}
	
	
	/**
	 * connect to database
	 * 
	 * @param connectionObject
	 * @return false if there is an Error in connection
	 * @throws SQLException
	 */
	public boolean connectToDatabase(DatabaseConnectionObject connectionObject) {

		ADDRESS = connectionObject.getHostAddress();
		PORT = connectionObject.getPort();
		USER = connectionObject.getUserName();
		PASSWORD = connectionObject.getPassword();

		try {
			// Establish Java MySQL connection
			connection = DriverManager.getConnection(
					URL + ADDRESS + ":" + PORT + "/" + DATABASENAME + "?" + CHARACTEREncoding + "&" + SSL, USER,
					PASSWORD);
			statement = connection.createStatement();
			if (statement.isClosed()) {
				connection.close();
				return false;
			} else
				return true;

		} catch (SQLException e) {
			System.out.println("ERROR: Unable to Connect to Database.");

			return false;
		}

	}
	/**
	 * Test Database connection
	 * 
	 * @param connectionObject
	 * @return
	 */
	public boolean testConnection(DatabaseConnectionObject connectionObject) {
		ADDRESS = connectionObject.getHostAddress();
		PORT = connectionObject.getPort();
		USER = connectionObject.getUserName();
		PASSWORD = connectionObject.getPassword();
		Connection connection = null;
		try {
			// Establish Java MySQL connection
			connection = DriverManager.getConnection(
					URL + ADDRESS + ":" + PORT + "/" + DATABASENAME + "?" + CHARACTEREncoding + "&" + SSL, USER,
					PASSWORD);
			Statement st = connection.createStatement();
			if (!st.isClosed()) {
				st.close();
				connection.close();
				return true;
			} else
				return false;

		} catch (SQLException e) {
			System.out.println("ERROR: Unable to Connect to Database.");

			return false;
		}

	}
	/**
	 * validation of User Name and Password
	 * 
	 * @param userName
	 * @param password
	 * @return
	 */
	public boolean isUserValid(String userName, String password) {
		boolean result = false;
		try {
			ResultSet resultSelect = statement.executeQuery("SELECT * FROM "+_tableName.user_tb.toString() +
															" where user_name='" + userName + "'");
			if (resultSelect.next()) {
				String recordedPassword = resultSelect.getString("password");
				if (recordedPassword.equals(password))
					result = true;

			}

		} catch (SQLException e) {
			result = false;
		}

		return result;
	}
	
	public ArrayList<String> getReleasesName() throws SQLException {
		ArrayList<String> result = new ArrayList<String>();
		try {
			ResultSet resultSelect = statement.executeQuery("SELECT * FROM "+_tableName.release_tb.toString()+" order by created_date DESC;");
			while (resultSelect.next()) {
								
				result.add(resultSelect.getString("release_name"));

			}

		} catch (SQLException e) {
			throw new SQLException("Error "+e.getMessage());
		}
		return result;
	}
	
	public ArrayList<CVEObject> getData(CVEDataState state,String releaseName) throws SQLException {
		String query="SELECT cve_tb.cve_id as cve, package_tb.package_name  as product,cve_tb.score as score,"
				+ " cve_tb.description as description,cve_tb.affected_version as comments,"
				+ " master_tb.status as master,"+releaseName+"_tb.Status as "+releaseName+", "+releaseName+"_tb.edited as edited "
				+ "FROM "+releaseName+"_tb, master_tb, cve_tb ,package_tb ,cve_package "
				+ "where cve_tb.cve_id="+releaseName+"_tb.cve_id and "
				+ "cve_tb.cve_id=master_tb.cve_id and "
				+ "cve_tb.cve_id=cve_package.cve_id and "
				+ "cve_package.package_id=package_tb.id and "
				+ "package_tb.id="+releaseName+"_tb.package_id" ;
		if(state==CVEDataState.NEW)
			query=query+" and "+releaseName+"_tb.edited=false";
					
		ArrayList<CVEObject> result = new ArrayList<CVEObject>();
		try {
			ResultSet resultSelect = statement.executeQuery(query);
			while (resultSelect.next()) {
				CVEObject obj = new CVEObject();
				obj.setCve(resultSelect.getString("cve"));
				obj.setProduct(resultSelect.getString("product"));
				obj.setScore(resultSelect.getDouble("score"));
				obj.setMaster(convertStringToValue(resultSelect.getString("master")));
				obj.setRelease(convertStringToValue(resultSelect.getString(releaseName)));
				obj.setDescription(resultSelect.getString("description"));
				obj.setEdited(resultSelect.getBoolean("edited"));
				obj.setComment(resultSelect.getString("comments"));
				result.add(obj);

			}

		} catch (SQLException e) {
			throw new SQLException("Error "+e.getMessage());
		}
		return result;
	}
	
	/**
	 * returns CVEObject
	 * 
	 * @param cve
	 * @return
	 * @throws SQLException
	 */
	public CVEObject getCVE(String cve, String productName ,String releaseName) throws SQLException {

		String query="SELECT "
				+ "cve_tb.cve_id as cve,package_tb.package_name  as product,cve_tb.score as score,cve_tb.description as description,"
				+ "cve_tb.affected_version as comments, master_tb.status as master"
				+ ","+releaseName+"_tb.Status as "+releaseName+", "+releaseName+"_tb.edited as edited ,"
				+ " cve_tb.vector as vector, cve_tb.more_information as information "
				+ "FROM cve_tb,package_tb,cve_package, master_tb,"+releaseName+"_tb "
				+ "where cve_tb.cve_id='"+cve+"' and "
				+ "package_tb.package_name='"+productName+"' and "
				+ "cve_tb.cve_id=cve_package.cve_id and "
				+ "cve_package.package_id=package_tb.id and "
				+ "cve_tb.cve_id="+releaseName+"_tb.cve_id and "
				+ "package_tb.id="+releaseName+"_tb.package_id and "
				+ "cve_tb.cve_id=master_tb.cve_id ";
		CVEObject obj = new CVEObject();
		try {
			ResultSet resultSelect = statement.executeQuery(query);
			if (resultSelect.next()) {

				obj.setCve(resultSelect.getString("cve"));
				obj.setProduct(resultSelect.getString("product"));
				obj.setScore(resultSelect.getDouble("score"));
				obj.setMaster(convertStringToValue(resultSelect.getString("master")));
				obj.setRelease(convertStringToValue(resultSelect.getString(releaseName)));
				obj.setDescription(resultSelect.getString("description"));
				obj.setEdited(resultSelect.getBoolean("edited"));
				obj.setComment(resultSelect.getString("comments"));
				obj.setVector(resultSelect.getString("vector"));
				obj.setMoreInformation(resultSelect.getString("information"));
			} else
				obj.setCve("");

		} catch (SQLException e) {
			throw new SQLException("Error "+e.getMessage());
		}
		return obj;
	}
	
	public int getProductId(String productName){
		String query="SELECT id FROM package_tb where package_name='"+productName+"';";
		try {
			ResultSet resultSelect = statement.executeQuery(query);
			if(resultSelect.next()){
				return resultSelect.getInt(1);
			}else return ITEM_NOT_FOUND;
		} catch (SQLException e) {
			
			e.printStackTrace();
			return CONNECTION_ERROR;
		}
		
	}
	
	public ArrayList<String> getProductList() throws SQLException {
		ArrayList<String> result = new ArrayList<String>();
		try {
			ResultSet resultSelect = statement.executeQuery("SELECT package_name FROM package_tb ;");
			while (resultSelect.next()) {
				
				
				result.add(resultSelect.getString(1));

			}

		} catch (SQLException e) {
			throw new SQLException("Error "+e.getMessage());
		}
		return result;
	}
	
	
	public String addNewProductName(String productName) {
		String result=null;
		String query="SELECT * FROM package_tb where package_name='"+productName+"'";
		
		try {
			connection.setAutoCommit(true);
			ResultSet resultSelect = statement.executeQuery(query);
			if (resultSelect.next()) {
				result="The "+productName+" already exist";
			}else{
				query="Insert into package_tb (package_name) value('"+productName+"')";	
				statement.execute(query);
				result="The "+productName+" has been added successfully";
			}

		} catch (SQLException e) {
			result=e.getMessage();
		}
		return result;
		
	}
	
	/**
	 * Update
	 * 
	 * @param data
	 * @throws SQLException
	 */
	public boolean updateRow(CVEObject data,String oldProductName) throws SQLException {
		int newProductId=getProductId(data.getProduct());

		String query="update master_tb,cve_tb,"+data.getReleaseName()+"_tb,"
				+ "package_tb,cve_package "
				+ "set cve_package.package_id=?,"

				+ "cve_tb.score=?,cve_tb.description=?,"
				+ "cve_tb.affected_version=?,"
				+ "cve_tb.more_information=?,"
				+ "cve_tb.vector=?,"
				+ "master_tb.status=?,"
				+ "master_tb.latest_edit=now(),"
				+ ""+data.getReleaseName()+"_tb.edited=1,"
				+ ""+data.getReleaseName()+"_tb.status=? ,"
				+ ""+data.getReleaseName()+"_tb.latest_edit=now() ,"
				+ ""+data.getReleaseName()+"_tb.package_id=? "
				+ "where cve_tb.cve_id=? and "
				+ "package_tb.package_name=? and "
				+ "cve_tb.cve_id=cve_package.cve_id and "
				+ "cve_package.package_id=package_tb.id and "
				+ "cve_tb.cve_id="+data.getReleaseName()+"_tb.cve_id and "
				+ "package_tb.id="+data.getReleaseName()+"_tb.package_id and "
				+ "cve_tb.cve_id=master_tb.cve_id ";
		PreparedStatement myPsmt;
		try {
			myPsmt = connection.prepareStatement(query);
			myPsmt.setInt(1, newProductId);

			myPsmt.setDouble(2, data.getScore());
			myPsmt.setString(3, data.getDescription());
			myPsmt.setString(4, data.getComment());
			myPsmt.setString(5, data.getMoreInformation());
			myPsmt.setString(6, data.getVector());
			myPsmt.setString(7, data.getMaster().toString());
			myPsmt.setString(8, data.getRelease().toString());
			myPsmt.setInt(9, newProductId);
			myPsmt.setString(10, data.getCve());
			myPsmt.setString(11, oldProductName);

			
			myPsmt.execute();
			
			
			return true;
		} catch (SQLException e) {
			if(e.getMessage().contains("Duplicate entry"))
				return false;
			else
				throw new SQLException("Error "+e.getMessage());
		}

	}
	
	public boolean deleteCVE(String cve, String releaseName,String productName) throws SQLException{
		
		int id=getProductId(productName);
				
		String query="delete FROM "+releaseName+"_tb "
				+ "where cve_id=? and "
				+ "package_id=?";
		PreparedStatement myPsmt;

		try{

			connection.setAutoCommit(false);
			myPsmt=connection.prepareStatement(query);
			myPsmt.setString(1, cve);
			myPsmt.setInt(2, id);
			
			myPsmt.execute();
			
			connection.commit();
			connection.setAutoCommit(true);
			return true;
		}catch(SQLException e){
			
			try {
				connection.rollback();
				connection.setAutoCommit(true);
				return false;
			} catch (SQLException e1) {
				
				e1.printStackTrace();
				throw new SQLException("Error "+e.getMessage());
				
			}
			
		}
		
	}
	
	
	public int addNewCVEToDatabase(CVEObject cveObject) throws SQLException  {
		int addedItems = 0;

			
		
			try {
				addNewProductName(cveObject.getProduct());
				int id=getProductId(cveObject.getProduct());
				connection.setAutoCommit(false);
					String queryAddCVE = "insert into cve_tb (cve_id,score,description,"
							+ "affected_version,more_information,vector)"
							+ "value(?,?,?,?,?,?)";
					PreparedStatement myPsmt = connection.prepareStatement(queryAddCVE);
					myPsmt.setString(1, cveObject.getCve());

					myPsmt.setDouble(2, cveObject.getScore());
					myPsmt.setString(3, cveObject.getDescription());
					myPsmt.setString(4, cveObject.getComment());
					myPsmt.setString(5, cveObject.getMoreInformation());
					myPsmt.setString(6, cveObject.getVector());
					
					myPsmt.execute();
					
					String queryAddCvePackage="insert into cve_package (cve_id,package_id)"
							+ "value(?,?)";
					myPsmt = connection.prepareStatement(queryAddCvePackage);
					myPsmt.setString(1, cveObject.getCve());
					myPsmt.setInt(2, id);
					myPsmt.execute();
					
					
					String queryAddmaster = "insert into master_tb(cve_id,status,latest_edit)"
							+ "value(?,?,now())";
					myPsmt = connection.prepareStatement(queryAddmaster);
					myPsmt.setString(1, cveObject.getCve());
					myPsmt.setString(2, cveObject.getMaster().toString());

					myPsmt.execute();
					

					
					String queryAddRelease = "insert into "+cveObject.getReleaseName()+"_tb "
							+ "(cve_id,package_id,status,latest_edit,edited)"
							+ "value(?,?,?,now(),?)";

					myPsmt = connection.prepareStatement(queryAddRelease);
					myPsmt.setString(1, cveObject.getCve());
					myPsmt.setInt(2, id);
					myPsmt.setString(3, cveObject.getRelease().toString());
					myPsmt.setBoolean(4, cveObject.isEdited());
					myPsmt.execute();

					connection.commit();
					connection.setAutoCommit(true);
					addedItems++;
					
			} catch (SQLException e) {

					connection.rollback();
					connection.setAutoCommit(true);
					if(!e.getMessage().contains("Duplicate entry"))
						throw new SQLException("Error "+e.getMessage());
			}

		

		return addedItems;
	}
	
	public int addNewCVEListToDatabase(ArrayList<CVEObject> data){
		int result=0;
		for (CVEObject cveObject : data) {
			
			try {
				if(!isCVEInCVETable(cveObject.getCve())){//insert
					if(addNewCVEToDatabase(cveObject)==1)
						result++;
				}else{//update
					if(updateCVEAndAddToMasterRelease(cveObject))
						result++;
				}
			} catch (SQLException e) {
				
				e.printStackTrace();
				return CONNECTION_ERROR;
			}
			
		}
		
		
		return result;
	}
	
	private boolean isCVEInCVETable(String cve) throws SQLException{

		String checkCVEQuery="select * from cve_tb where "
				+ "cve_id='"+cve+"'";
		ResultSet resultSelect = statement.executeQuery(checkCVEQuery);
		
		return resultSelect.next();
	}
	
	private ResultSet getCVEfromCVETable(String cve) throws SQLException{
		String checkCVEQuery="select * from cve_tb where trim(cve_id)='"+cve+"'";
		ResultSet resultSelect = statement.executeQuery(checkCVEQuery);
		
		return resultSelect;
	}
	private boolean updateCVEAndAddToMasterRelease(CVEObject cveObject) throws SQLException{
		addNewProductName(cveObject.getProduct());
		int id=getProductId(cveObject.getProduct());
		try {
				connection.setAutoCommit(false);
				ResultSet resultSelect=getCVEfromCVETable(cveObject.getCve().trim());
				String queryUpdateCVE = "Update cve_tb SET ";//product=?,score=?,description=?,edited=?,affectedVersion=? Where cve=?";
				boolean isvalidUpdate=false;
				if(resultSelect.next())
					if(resultSelect.getString("vector").isEmpty()&&!cveObject.getVector().isEmpty()){
						isvalidUpdate=true;
						queryUpdateCVE+="vector ='"+cveObject.getVector()+"'";
					}
					if(resultSelect.getString("more_information").isEmpty()&&!cveObject.getMoreInformation().isEmpty()){
						isvalidUpdate=true;
						if(queryUpdateCVE.contains("vector"))
							queryUpdateCVE+=", more_information ='"+cveObject.getMoreInformation()+"'";
						else
							queryUpdateCVE+="more_information ='"+cveObject.getMoreInformation()+"'";
					}
					
					if(isvalidUpdate){
						queryUpdateCVE+=" where trim(cve_id)='"+cveObject.getCve().trim()+"' and package_name_id="+id+";";
						
							statement.execute(queryUpdateCVE);
							connection.commit();
					}
			} catch (SQLException e) {
				e.printStackTrace();
				throw new SQLException("Error "+e.getMessage());
			}
			try{
				String queryAddmaster = "insert into cve_package(cve_id,package_id)"
						+ "value(?,?)";
				PreparedStatement myPsmt = connection.prepareStatement(queryAddmaster);
				myPsmt.setString(1, cveObject.getCve());
				myPsmt.setInt(2,id);
				myPsmt.execute();
				
	
				
				connection.commit();
			}catch(SQLException error){
				if(error.getMessage().contains("Duplicate entry")){
					try {
						connection.rollback();
					} catch (SQLException e) {
						throw new SQLException("Error "+e.getMessage());
					}
				}else{//connection error
					throw new SQLException("Error "+error.getMessage());
				}
			}
			
			try{
				String queryAddmaster = "insert into master_tb(cve_id,status,latest_edit)"
						+ "value(?,?,now())";
				PreparedStatement myPsmt = connection.prepareStatement(queryAddmaster);
				myPsmt.setString(1, cveObject.getCve());
				myPsmt.setString(2, cveObject.getMaster().toString());
				myPsmt.execute();
				

				
				connection.commit();
			}catch(SQLException error){
				if(error.getMessage().contains("Duplicate entry")){
					try {
						connection.rollback();
					} catch (SQLException e) {
						throw new SQLException("Error "+e.getMessage());
					}
				}else{//connection error
					throw new SQLException("Error "+error.getMessage());
				}
			}
			
		try{
			String queryAddRelease = "insert into "+cveObject.getReleaseName()+"_tb "
					+ "(cve_id,package_id,status,latest_edit,edited)"
					+ "value(?,?,?,now(),?)";

			PreparedStatement myPsmt = connection.prepareStatement(queryAddRelease);
			myPsmt.setString(1, cveObject.getCve());
			myPsmt.setInt(2, id);
			myPsmt.setString(3, cveObject.getRelease().toString());
			myPsmt.setBoolean(4, cveObject.isEdited());
			myPsmt.execute();
			

			connection.commit();
			connection.setAutoCommit(true);
			return true;
		}catch(SQLException error){
			if(error.getMessage().contains("Duplicate entry")){
				try {
					connection.rollback();
					connection.setAutoCommit(true);
					return false;
				} catch (SQLException e) {
					throw new SQLException("Error "+e.getMessage());
				}
			}else{//connection error
				throw new SQLException("Error "+error.getMessage());
			}
		}
		
		
	}

	public String addRelase(String releaseName) throws SQLException {
		
		String query;
		try {
			ResultSet resultSelect = statement
					.executeQuery("SELECT * FROM release_tb where release_tb.release_name='"+releaseName+"';");
			if (!resultSelect.next()) {

				connection.setAutoCommit(false);
				
				query="CREATE TABLE `"+releaseName+"_tb` "
						+ "(`cve_id` VARCHAR(20) NOT NULL,`package_id` INT(11) NOT NULL,"
						+ "`latest_edit` DATETIME NULL,`status` TEXT NULL,`edited` TINYINT(4) NULL,"
						+ "PRIMARY KEY (`cve_id`, `package_id`)); ";
				PreparedStatement myPsmt = connection.prepareStatement(query);
				myPsmt.executeUpdate();
				query = "INSERT ignore INTO release_tb (release_tb.release_name,release_tb.created_date) VALUES (?,NOW())";
				myPsmt = connection.prepareStatement(query);
				myPsmt.setString(1, releaseName);
				myPsmt.execute();

				connection.commit();
				connection.setAutoCommit(true);
				return "OK";
				}else 
					return "Already Exist";

		} catch (SQLException e) {
			connection.rollback();
			connection.setAutoCommit(true);


			throw new SQLException("Error "+e.getMessage());
		}

		
	}
	
	public String getSpecialQuery(String query, OutPutFormat formatter,String releaseName) throws SQLException{
		
		String resultString = "";
		try {
			ResultSet resultSelect = statement.executeQuery(query.replace(';', ' ') + "order by SUBSTRING_INDEX(SUBSTRING_INDEX(cve, '-', -2), '-', 1) desc , CONVERT(SUBSTRING_INDEX(cve, '-', -1),UNSIGNED INTEGER) desc;");
			while (resultSelect.next()) {

				try {
					String cve = resultSelect.getString("cve");

					if (formatter.isCve())
						resultString += "CVE name" + formatter.getSeparationSignBetweenColumnNameAndValue() + " " + cve
								+ formatter.getSeparationSignBetweenColumns();
					else
						resultString += cve + formatter.getSeparationSignBetweenColumns();
				} catch (SQLException cve) {

				}
				try {
					if (formatter.isProduct())
						resultString += "Package" + formatter.getSeparationSignBetweenColumnNameAndValue() + " "
								+ resultSelect.getString("product") + formatter.getSeparationSignBetweenColumns();
					else
						resultString += resultSelect.getString("product") + formatter.getSeparationSignBetweenColumns();
				} catch (SQLException cve) {

				}
				try {
					double score = resultSelect.getDouble("score");
					String txScore;
					if (score >= 7 && score <= 10)
						txScore = " (High)";
					else if (score >= 4 && score <= 6.9)
						txScore = " (Medium)";
					else
						txScore = " (Low)";
					if (formatter.isScore())
						resultString += "Score" + formatter.getSeparationSignBetweenColumnNameAndValue() + " "
								+ Double.toString(score) + txScore + formatter.getSeparationSignBetweenColumns();
					else
						resultString += Double.toString(score) + txScore + formatter.getSeparationSignBetweenColumns();
				} catch (SQLException cve) {

				}
				try {
					if (formatter.isMaster())
						resultString += "Status Master" + formatter.getSeparationSignBetweenColumnNameAndValue() + " "
								+ resultSelect.getString("master") + formatter.getSeparationSignBetweenColumns();
					else
						resultString += resultSelect.getString("master") + formatter.getSeparationSignBetweenColumns();
				} catch (SQLException cve) {

				}
				try {
					if (formatter.isEL7())
						resultString += "Status "+releaseName+"" + formatter.getSeparationSignBetweenColumnNameAndValue() + " "
								+ resultSelect.getString(releaseName) + formatter.getSeparationSignBetweenColumns();
					else
						resultString += resultSelect.getString(releaseName) + formatter.getSeparationSignBetweenColumns();
				} catch (SQLException cve) {

				}

				try {
					if (formatter.isDescription())
						resultString += "Description" + formatter.getSeparationSignBetweenColumnNameAndValue() + " "
								+ resultSelect.getString("description").replaceAll("\n", "")
								+ formatter.getSeparationSignBetweenColumns();
					else
						resultString += resultSelect.getString("description").replaceAll("\n", "")
								+ formatter.getSeparationSignBetweenColumns();
				} catch (SQLException cve) {

				}
				try {
					String cve = resultSelect.getString("cve");
					String hyperlink = "";
					if (formatter.isHyperlinkSelected())
						if (formatter.isHyperlinkColumnName()) {
							hyperlink = "Ref" + formatter.getSeparationSignBetweenColumnNameAndValue()
									+ " https://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve
									+ formatter.getSeparationSignBetweenColumns();
						} else {
							hyperlink = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve
									+ formatter.getSeparationSignBetweenColumns();
						}

					resultString += hyperlink;

				} catch (SQLException cve) {

				}
				resultString += "\n";

			}

		} catch (SQLException e) {
			throw new SQLException("Connection fauil");
		}
		return resultString;
	
	}
	
	/**
	 * Converts String to CVEObject.Value
	 * 
	 * @param text
	 * @return
	 */
	private CVEObject.ColumnValues convertStringToValue(String text) {
		if (CVEObject.ColumnValues.Fixed.toString().equals(text))
			return CVEObject.ColumnValues.Fixed;
		else if (CVEObject.ColumnValues.NotFixed.toString().equals(text))
			return CVEObject.ColumnValues.NotFixed;
		else if (CVEObject.ColumnValues.Unknown.toString().equals(text))
			return CVEObject.ColumnValues.Unknown;
		else if (CVEObject.ColumnValues.NA.toString().equals(text))
			return CVEObject.ColumnValues.NA;
		else if (CVEObject.ColumnValues.InProgress.toString().equals(text))
			return CVEObject.ColumnValues.InProgress;
		else
			return CVEObject.ColumnValues.Empty;
	}
}
